import re

include: '../Snakefile'

configfile: 'config.yaml'
MOLECULES = get_all_inputs()
METHODS = config['METHODS']
BASES = config['BASES']
JASTROW_RANKS = config['JASTROW_RANKS']
STABILITY_ANALYSIS = config['STABILITY_ANALYSIS']

def hf_energy(*path):
    """Get QCHEM output energy."""
    regexp = re.compile(' Total energy in the final basis set =\s+(?P<energy>[-+]?\d+\.\d+)')
    with open(os.path.join(*path, 'mol.out'), 'r') as qchem_out:
        # we are only interested in the last occurrence
        energy = float(re.findall(regexp, qchem_out.read())[-1])
    return energy

def hf_time(*path):
    """Get QCHEM time."""
    regexp = re.compile(' Total job time:\s+(?P<time>\d+\.\d+)s\(wall\)')
    with open(os.path.join(*path, 'mol.out'), 'r') as qchem_out:
        # we are only interested in the last occurrence
        time = float(re.findall(regexp, qchem_out.read())[-1])
    return time

def get_up_down(*path):
    """Get up and down electron numbers from QCHEM output file.
     There are        2 alpha and        2 beta electrons
    """

    regexp = re.compile('There are\s+(?P<alpha>\d+) alpha and\s+(?P<beta>\d+) beta electrons')
    with open(os.path.join(*path, 'mol.out'), 'r') as qchem_out:
        for line in qchem_out:
            m = re.search(regexp, line)
            if m:
                neu = int(m.group('alpha'))
                ned = int(m.group('beta'))
    return neu, ned

wildcard_constraints:
    multideterminant_method='OD|OD\(2\)|VOD|VOD\(2\)|QCCD|QCCD\(2\)|VQCCD',
    order='\d+'

rule ALL:
    input:
        expand('{method}/{basis}/{molecule}/VMC/10000000/out', molecule=MOLECULES, basis=BASES, method=METHODS),
        expand('{method}/{basis}/{molecule}/VMC_OPT/emin/{jastrow_rank}/1000000_9/out', molecule=MOLECULES, basis=BASES, method=METHODS, jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC/emin/{jastrow_rank}/tmax_2_1024_1/out', molecule=MOLECULES, basis=BASES, method=METHODS, jastrow_rank=JASTROW_RANKS),

rule ALL_VMC_DMC:
    input:
        expand('{method}/{basis}/{molecule}/VMC_DMC/emin/{jastrow_rank}/tmax_2_1024_1/out', molecule=MOLECULES, basis=BASES, method=METHODS, jastrow_rank=JASTROW_RANKS),

rule ALL_VMC_OPT_ENERGY:
    input:
        expand('{method}/{basis}/{molecule}/VMC_OPT/emin/{jastrow_rank}/1000000_9/out', molecule=MOLECULES, basis=BASES, method=METHODS, jastrow_rank=JASTROW_RANKS),

rule ALL_VMC_OPT:
    input:
        expand('{method}/{basis}/{molecule}/VMC_OPT/emin/{jastrow_rank}/10000/out', molecule=MOLECULES, basis=BASES, method=METHODS, jastrow_rank=JASTROW_RANKS),

rule ALL_VMC:
    input:
        expand('{method}/{basis}/{molecule}/VMC/10000000/out', molecule=MOLECULES, basis=BASES, method=METHODS),

rule ALL_QCHEM:
    input:
        expand('{method}/{basis}/{molecule}/gwfn.data', molecule=MOLECULES, basis=BASES, method=METHODS),

###################################################################################################################

ruleorder:
    MULTIDETERMINENT_GWFN > GWFN

rule MULTIDETERMINENT_GWFN:
    input:      '{multideterminant_method}/{basis}/{molecule}/gwfn.data'
    output:     '{multideterminant_method}_{order}/{basis}/{molecule}/gwfn.data'
    shell:
        """
        cd "{wildcards.multideterminant_method}_{wildcards.order}/{wildcards.basis}/{wildcards.molecule}" &&
        ln -s "../../../{wildcards.multideterminant_method}/{wildcards.basis}/{wildcards.molecule}/gwfn.data" &&
        ln -s "../../../{wildcards.multideterminant_method}/{wildcards.basis}/{wildcards.molecule}/mol.out" &&
        multideterminant.py 7 mol.out --truncate "{wildcards.order}"
        """

rule GWFN:
    input:      '{method}/{basis}/{molecule}/mol.molden'
    output:     '{method}/{basis}/{molecule}/gwfn.data'
    run:
        shell('molden2qmc.py 7 "{input}" "{output}"')

pat1 = '======= MOLDEN-FORMATTED INPUT FILE FOLLOWS ======='
pat2 = '======= END OF MOLDEN-FORMATTED INPUT FILE ======='

rule MOLDEN:
    input:      '{method}/{basis}/{molecule}/mol.out'
    output:     '{method}/{basis}/{molecule}/mol.molden'
    params:      pattern='/%(pat1)s/,/%(pat2)s/{/%(pat1)s/!{/%(pat2)s/!p}}' % {'pat1': pat1, 'pat2': pat2}
    shell:      'sed -n "{params.pattern}" "{input}" > "{output}"'

rule QCHEM_RUN:
    input:      config['INPUTS_DIR'] + '/{molecule}.xyz'
    output:     '{method}/{basis}/{molecule}/mol.out'
    run:
        stability_analysis = STABILITY_ANALYSIS
        qchem_input = os.path.join(wildcards.method, wildcards.basis, wildcards.molecule, 'mol.in')
        for algorithm in ('diis', 'gdm'):
            # set template
            if wildcards.method in ('OD', 'OD(2)', 'VOD', 'VOD(2)', 'QCCD', 'QCCD(2)', 'VQCCD'):
                template = 'qchem_multideterminant.tmpl'
            else:
                template = 'qchem.tmpl'
            with open(input[0], 'r') as f:
                f.readline()                   # skip first line
                molecule_data = f.read()[:-1]  # skip last NL
            if wildcards.basis.endswith('_PP'):
                basis = wildcards.basis.split('_')[0]
                template = 'qchem_ecp.tmpl'
                with open(qchem_input, 'w') as f:
                    f.write(open(template).read().format(
                        basis=basis,
                        method=wildcards.method,
                        molecule_data=molecule_data,
                        algorithm=algorithm,
                        stability_analysis=stability_analysis,
                        external_ecp=open('ppotential/DiracFock_AREP_gaussian.bas').read()
                    ))
            else:
                with open(qchem_input, 'w') as f:
                    f.write(open(template).read().format(
                        basis=wildcards.basis,
                        method=wildcards.method,
                        molecule_data=molecule_data,
                        algorithm=algorithm,
                        stability_analysis=stability_analysis
                    ))
            shell('qchem -nt 4 "{qchem_input}" "{output}"')
            if 'Convergence criterion met' in open(output[0]).read():
                break
