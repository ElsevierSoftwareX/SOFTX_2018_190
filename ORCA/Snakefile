import os
import multiprocessing
from datetime import timedelta

PROCS = multiprocessing.cpu_count()

include: '../Snakefile'

ORCA_PATH = os.getenv('HOME') + '/bin/orca_4_0_1_2_linux_x86-64_shared_openmpi202',
ORCA_LIBS = os.getenv('HOME') + '/ORCA_EXT_LIBS'

MOLECULES = ['he', 'li', 'n', 'o', 'f', 'ne']
METHODS = ['B3LYP']
BASES = ['ano-pVDZ'] #, 'ano-pVTZ', 'ano-pVQZ', 'cc-pVDZ', 'cc-pVTZ', 'cc-pVQZ']
JASTROW_RANKS = ['8_8_44', 'a_ra_44', '8_8_4ra', 'a_ra_4ra']

def hf_energy(*path):
    """Get ORCA output energy."""
    regexp = re.compile('FINAL SINGLE POINT ENERGY\s+(?P<energy>[-+]?\d+\.\d+)')
    with open(os.path.join(*path, 'mol.out'), 'r') as orca_out:
        # we are only interested in the last occurrence
        energy = float(re.findall(regexp, orca_out.read())[-1])
    return energy

def hf_time(*path):
    """Get ORCA time."""
    regexp = re.compile('TOTAL RUN TIME: (?P<days>\d+) days (?P<hours>\d+) hours (?P<minutes>\d+) minutes (?P<seconds>\d+) seconds (?P<msec>\d+) msec')
    total_seconds = 0.0
    with open(os.path.join(*path, 'mol.out'), 'r') as orca_out:
        m = list(map(int, re.findall(regexp, orca_out.read())[-1]))
        if m:
            total_seconds = timedelta(days=m[0], hours=m[1], minutes=m[2], seconds=m[3], milliseconds=m[4]).total_seconds()
    return total_seconds

def get_up_down(*path):
    """Get up and down electron numbers from ORCA output file.
    Number of up&down electrons required in CASINO input.
    """

    regexp1 = re.compile('Multiplicity           Mult            ....\s+(?P<mult>\d+)')
    regexp2 = re.compile('Number of Electrons    NEL             ....\s+(?P<elec>\d+)')
    with open(os.path.join(*path, 'mol.out'), 'r') as orca_out:
        for line in orca_out:
            m1 = re.search(regexp1, line)
            if m1:
                mult = int(m1.group('mult'))
            m2 = re.search(regexp2, line)
            if m2:
                elec = int(m2.group('elec'))
    neu = (elec + mult - 1)//2
    ned = (elec - mult + 1)//2
    return neu, ned

def get_nelec(*path):
    """Get total electron numbers from ORCA output file.
    """
    regexp = re.compile('Number of Electrons    NEL             ....\s+(?P<elec>\d+)')
    with open(os.path.join(*path, 'mol.out'), 'r') as orca_out:
        for line in orca_out:
            m = re.search(regexp, line)
            if m:
                elec = int(m.group('elec'))
    return elec

rule ALL:
    input:
        expand('{method}/{basis}/{molecule}/VMC/10000000/out', method=METHODS, basis=BASES, molecule=MOLECULES),
        expand('{method}/{basis}/{molecule}/VMC_OPT/emin/{jastrow_rank}/1000000_9/out', method=METHODS, basis=BASES, molecule=MOLECULES, jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC/emin/{jastrow_rank}/tmax_2_1024_1/out', method=METHODS, basis=BASES, molecule=MOLECULES, jastrow_rank=JASTROW_RANKS),

rule ALL_VMC_DMC:
    input:
        expand('{method}/{basis}/{molecule}/VMC_DMC/emin/{jastrow_rank}/tmax_2_1024_1/out', method=METHODS, basis=BASES, molecule=MOLECULES, jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC_BF/bf_plan_A/{jastrow_rank}__9_9_33/tmax_2_1024_1/out', method=METHODS, basis=BASES, molecule=MOLECULES, jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC/emin/{jastrow_rank}/tmax_2_1024_1/out', method='CASSCF_2_4', basis=BASES, molecule='be', jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC/emin/{jastrow_rank}/tmax_2_1024_1/out', method='CASSCF_3_4', basis=BASES, molecule='b', jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC/emin/{jastrow_rank}/tmax_2_1024_1/out', method='CASSCF_4_4', basis=BASES, molecule='c', jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC_BF/bf_plan_A/{jastrow_rank}__9_9_33/tmax_2_1024_1/out', method='CASSCF_2_4', basis=BASES, molecule='be', jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC_BF/bf_plan_A/{jastrow_rank}__9_9_33/tmax_2_1024_1/out', method='CASSCF_3_4', basis=BASES, molecule='b', jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC_BF/bf_plan_A/{jastrow_rank}__9_9_33/tmax_2_1024_1/out', method='CASSCF_4_4', basis=BASES, molecule='c', jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC_BF/bf_plan_A/{jastrow_rank}__9_9_33/tmax_2_1024_1/out', method='CASSCF_3_4', basis=BASES, molecule='al', jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC_BF/bf_plan_A/{jastrow_rank}__9_9_33/tmax_2_1024_1/out', method='CASSCF_4_4', basis=BASES, molecule='si', jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC_BF/bf_plan_A/{jastrow_rank}__9_9_33/tmax_2_1024_1/out', method='CASSCF_4_8', basis=BASES, molecule='be2', jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_DMC_BF/bf_plan_A/{jastrow_rank}__9_9_33/tmax_2_1024_1/out', method='CASSCF_6_8', basis=BASES, molecule='b2', jastrow_rank=JASTROW_RANKS),


rule ALL_VMC_OPT_ENERGY:
    input:
        expand('{method}/{basis}/{molecule}/VMC_OPT/emin/{jastrow_rank}/1000000_9/out', molecule=MOLECULES, basis=BASES, method=METHODS, jastrow_rank=JASTROW_RANKS),

rule ALL_VMC_OPT:
    input:
        expand('{method}/{basis}/{molecule}/VMC_OPT/emin/{jastrow_rank}/10000/out', method=METHODS, basis=BASES, molecule=MOLECULES, jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_OPT/emin/{jastrow_rank}/10000/out', method='CASSCF_2_4', basis=BASES, molecule='be', jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_OPT/emin/{jastrow_rank}/10000/out', method='CASSCF_3_4', basis=BASES, molecule='b', jastrow_rank=JASTROW_RANKS),
        expand('{method}/{basis}/{molecule}/VMC_OPT/emin/{jastrow_rank}/10000/out', method='CASSCF_4_4', basis=BASES, molecule='c', jastrow_rank=JASTROW_RANKS),

rule ALL_VMC:
    input:
        expand('{method}/{basis}/{molecule}/VMC/10000000/out', method=METHODS, basis=BASES, molecule=MOLECULES),

rule ALL_ORCA:
    input:
        expand('{method}/{basis}/{molecule}/gwfn.data', method=METHODS, basis=BASES, molecule=MOLECULES),
        expand('{method}/{basis}/{molecule}/gwfn.data', method='MP2', basis=BASES', molecule=MOLECULES),
        expand('{method}/{basis}/{molecule}/gwfn.data', method='OO-RI-MP2', basis=BASES, molecule=MOLECULES),
        expand('{method}/{basis}/{molecule}/gwfn.data', method='OOCCD', basis=BASES, molecule=MOLECULES),
        expand('{method}/{basis}/{molecule}/gwfn.data', method='DLPNO-CCSD_T', basis=BASES, molecule=MOLECULES),

#####################################################################################################################

rule MDET:
    input:      '{multideterminant_method}/{basis}/{molecule}/mol.out'
    output:     '{multideterminant_method}/{basis}/{molecule}/correlation.data'
    wildcard_constraints:
        multideterminant_method='CASSCF_\d+_\d+'
    shell:      'cd "$(dirname "{output}")" && multideterminant.py 3 mol.out'

rule GWFN:
    input:      '{method}/{basis}/{molecule}/mol.molden.input'
    output:     '{method}/{basis}/{molecule}/gwfn.data'
    run:
        # workaround for pseudo potential
        if wildcards.basis.endswith('_PP'):
            shell('molden2qmc.py 3 {input} {output} --pseudoatoms all')
        else:
            shell('molden2qmc.py 3 {input} {output}')
        # workaround for multireference case
        if wildcards.method.startswith('CASSCF'):
            shell('cd "$(dirname "{output}")" && multideterminant.py 3 mol.out')

rule MOLDEN:
    input:      '{method}/{basis}/{molecule}/mol.out'
    output:     '{method}/{basis}/{molecule}/mol.molden.input'
    run:
        if wildcards.method == 'OO-RI-MP2' and wildcards.molecule != 'h':
            shell("""export PATH={ORCA_PATH}:{ORCA_LIBS}/bin:$PATH &&
                     export LD_LIBRARY_PATH={ORCA_LIBS}/lib:{ORCA_PATH} &&
                     cd "$(dirname "{output}")" &&
                     ln -s mol.mp2nat mol.mp2nat.gbw &&
                     {ORCA_PATH}/orca_2mkl mol.mp2nat -molden &&
                     ln -s mol.mp2nat.molden.input mol.molden.input""")
        if wildcards.method == 'OOCCD':
            shell("""export PATH={ORCA_PATH}:{ORCA_LIBS}/bin:$PATH &&
                     export LD_LIBRARY_PATH={ORCA_LIBS}/lib:{ORCA_PATH} &&
                     cd "$(dirname "{output}")" &&
                     ln -s mol.mdci.optorb mol.mdci.gbw &&
                     {ORCA_PATH}/orca_2mkl mol.mdci -molden &&
                     ln -s mol.mdci.molden.input mol.molden.input""")
        else:
            shell("""export PATH={ORCA_PATH}:{ORCA_LIBS}/bin:$PATH &&
                     export LD_LIBRARY_PATH={ORCA_LIBS}/lib:{ORCA_PATH} &&
                     cd "$(dirname "{output}")" &&
                     {ORCA_PATH}/orca_2mkl mol -molden""")

rule ORCA_RUN:
    input:      '{path}/mol.inp'
    output:     '{path}/mol.out'
    shell:    """export PATH={ORCA_PATH}:{ORCA_LIBS}/bin:$PATH &&
                 export LD_LIBRARY_PATH={ORCA_LIBS}/lib:{ORCA_PATH} &&
                 cd {wildcards.path} && {ORCA_PATH}/orca mol.inp > mol.out"""

extra_basis = (
"""%basis
  newGTO H
    "cc-pVQZ"
  end
end""")

rule ORCA_INPUT:
    input:      '../chem_database/{molecule}.xyz'
    output:     '{method}/{basis}/{molecule}/mol.inp'
    run:
        with open(input[0], 'r') as xyz:
            charge, multiplicity = xyz.readlines()[1].split()
        with open(output[0], 'w') as f:
            if wildcards.method.startswith('CASSCF'):
                f.write(open('orca_casscf.tmpl').read().format(
                    basis=wildcards.basis,
                    method='HF',
                    molecule=wildcards.molecule,
                    charge=charge,
                    multiplicity=multiplicity,
                    nel=wildcards.method.split('_')[1],
                    norb=wildcards.method.split('_')[2]
                ))
            elif wildcards.basis.endswith('_PP'):
                basis = wildcards.basis.split('_')[0]
                if basis in ('aug-cc-pVDZ-CDF', 'aug-cc-pVTZ-CDF', 'aug-cc-pVQZ-CDF', 'aug-cc-pV5Z-CDF'):
                    external_basis = """GTOName = "../../../../basis/{}.bas";""".format(basis)
                    basis = 'cc-pVDZ'
                else:
                    external_basis = ""
                f.write(open('orca_ecp.tmpl').read().format(
                    basis=basis,
                    method=wildcards.method,
                    molecule=wildcards.molecule,
                    charge=charge,
                    multiplicity=multiplicity,
                    external_basis=external_basis,
                    external_ecp=open('ppotential/DiracFock_AREP_gaussian.bas').read()
                ))
            elif wildcards.method == 'DLPNO-CCSD_T':
                f.write(open('orca_dlpno_ccsdt.tmpl').read().format(
                    basis=wildcards.basis,
                    aux_basis='cc-pVQZ/C',
                    extra_basis=extra_basis if wildcards.basis=='cc-pCVQZ' else '',
                    extra_params='! NoFrozenCore' if wildcards.basis=='cc-pCVQZ' else '',
                    method='DLPNO-CCSD(T)',
                    molecule=wildcards.molecule,
                    charge=charge,
                    multiplicity=multiplicity,
                    procs='! PAL{}'.format(PROCS)
                ))
            elif wildcards.method == 'OO-RI-MP2':
                f.write(open('orca_oo_mp2.tmpl').read().format(
                    basis=wildcards.basis,
                    aux_basis=wildcards.basis + '/C',
                    extra_basis=extra_basis if wildcards.basis=='cc-pCVQZ' else '',
                    extra_params='! NoFrozenCore' if wildcards.basis=='cc-pCVQZ' else '',
                    method='OO-RI-MP2',
                    molecule=wildcards.molecule,
                    charge=charge,
                    multiplicity=multiplicity,
                    procs='! PAL{}'.format(PROCS)
                ))
            elif wildcards.method == 'OOCCD':
                f.write(open('orca_oo_ccd.tmpl').read().format(
                    basis=wildcards.basis,
                    aux_basis='cc-pVQZ/C',
                    extra_basis=extra_basis if wildcards.basis=='cc-pCVQZ' else '',
                    extra_params='! NoFrozenCore' if wildcards.basis=='cc-pCVQZ' else '',
                    method='OOCCD',
                    molecule=wildcards.molecule,
                    charge=charge,
                    multiplicity=multiplicity,
                    procs='! PAL{}'.format(PROCS)
                ))
            else:
                if wildcards.molecule in ('c-hooo',) and wildcards.method == 'HF':
                    method = 'ROHF'
                else:
                    method = wildcards.method
                f.write(open('orca.tmpl').read().format(
                    basis=wildcards.basis,
                    extra_basis=extra_basis if wildcards.basis=='cc-pCVQZ' else '',
                    extra_params='! NoFrozenCore' if wildcards.basis=='cc-pCVQZ' else '',
                    method=method,
                    molecule=wildcards.molecule,
                    charge=charge,
                    multiplicity=multiplicity
                ))
